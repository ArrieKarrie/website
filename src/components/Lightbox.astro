---
import type { ImageMetadata } from 'astro';

interface Props {
    images: ImageMetadata[]; 
}

const { images } = Astro.props;
---

<div id="lightbox">
    <div class="relative z-10 p-4 w-full h-full flex flex-col justify-center items-center pointer-events-none">
        <img 
            id="lightboxImg" 
            src="" 
            alt="Lightbox View" 
            class="max-w-full max-h-[85vh] object-contain shadow-2xl pointer-events-auto will-change-opacity"
        />
    </div>

    <div class="absolute bottom-6 left-0 right-0 z-20 pointer-events-none select-none">
        <div id="controls" class="flex justify-center items-center w-full h-full relative text-[var(--color-text-primary-light)] dark:text-[var(--color-text-primary-dark)]">
            <div class="flex items-center gap-[min(1.9svw,3.84svh)] pointer-events-auto">
                <button id="lbPrev" class="nav-btn group" aria-label="Previous">
                    <span class="underline-anim anim-right">&larr; Prev</span>
                </button>
                
                <div id="lbCounter" class="nav-text">1 / 1</div>
                
                <button id="lbNext" class="nav-btn group" aria-label="Next">
                    <span class="underline-anim anim-left">Next &rarr;</span>
                </button>
            </div>
        </div>
    </div>
</div>

<script define:vars={{ images }}>
    document.addEventListener('astro:page-load', () => {
        // Elements
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightboxImg');
        const lbPrev = document.getElementById('lbPrev');
        const lbNext = document.getElementById('lbNext');
        const lbCounter = document.getElementById('lbCounter');
        const blurredOverlay = document.getElementById('blurredOverlay');

        if (!lightbox) return;

        // State
        let isLbAnimating = false;
        let currentLbIndex = 0;
        const totalImages = images ? images.length : 0;

        // --- OPTIMIZATION 1: Preload Neighbors ---
        // Quietly fetch the next and previous images so they are ready in cache
        function preloadNeighbors(index) {
            if (!images || totalImages === 0) return;
            
            const nextIndex = (index + 1) % totalImages;
            const prevIndex = (index - 1 + totalImages) % totalImages;

            const imgNext = new Image(); imgNext.src = images[nextIndex].src;
            const imgPrev = new Image(); imgPrev.src = images[prevIndex].src;
        }

        // Logic
        function updateCounter(index) {
            if(lbCounter) lbCounter.innerText = `${index + 1} / ${totalImages}`;
        }

        function openLightbox(index) {
            if (!lightbox || !lightboxImg) return;
            
            currentLbIndex = index;
            lightboxImg.src = images[index].src;
            updateCounter(index);
            
            if(blurredOverlay) {
                blurredOverlay.classList.add('open');
                blurredOverlay.style.zIndex = "11"; 
            }
            lightbox.classList.add('open');
            
            // Start preloading immediately
            preloadNeighbors(index);
        }

        function closeLightbox() {
            if (!lightbox) return;
            
            if(blurredOverlay) blurredOverlay.classList.remove('open');
            lightbox.classList.remove('open');
            
            setTimeout(() => {
                if(lightboxImg) lightboxImg.src = "";
                if(blurredOverlay) blurredOverlay.style.zIndex = "";
            }, 350);
        }

        // --- OPTIMIZATION 2: Parallel Loading ---
        // Don't wait for fade-out to finish before fetching the image. Do both at once.
        function changeImage(direction) {
            if (isLbAnimating || !lightboxImg) return;
            isLbAnimating = true;

            // 1. Determine next index
            let nextIndex;
            if (direction === 'next') {
                nextIndex = (currentLbIndex + 1) >= totalImages ? 0 : currentLbIndex + 1;
            } else {
                nextIndex = (currentLbIndex - 1) < 0 ? totalImages - 1 : currentLbIndex - 1;
            }

            // 2. Start Animation AND Image Load simultaneously
            lightboxImg.classList.add('opacity-0'); // CSS Transition (350ms)
            updateCounter(nextIndex); // Optimistic UI update

            const nextSrc = images[nextIndex].src;

            // Promise 1: Wait for CSS fade out (fixed time)
            const fadePromise = new Promise(resolve => setTimeout(resolve, 350));

            // Promise 2: Wait for Image to download (variable time)
            const loadPromise = new Promise(resolve => {
                const tempLoader = new Image();
                tempLoader.src = nextSrc;
                if (tempLoader.complete) {
                    resolve();
                } else {
                    tempLoader.onload = resolve;
                    tempLoader.onerror = resolve; // Prevent hanging on error
                }
            });

            // 3. Update DOM only when BOTH are ready
            Promise.all([fadePromise, loadPromise]).then(() => {
                currentLbIndex = nextIndex;
                lightboxImg.src = nextSrc;
                
                // Force a browser reflow to ensure the fade-in triggers
                void lightboxImg.offsetWidth;
                
                lightboxImg.classList.remove('opacity-0');
                isLbAnimating = false;

                // Preload for the next click
                preloadNeighbors(currentLbIndex);
            });
        }

        // --- OPTIMIZATION 3: Event Delegation ---
        // Instead of adding listeners to every single image, add one to the body
        const handleGalleryClick = (e) => {
            const item = e.target.closest('.gallery-item');
            if (item) {
                const index = parseInt(item.getAttribute('data-index'));
                if (!isNaN(index)) openLightbox(index);
            }
        };

        document.body.addEventListener('click', handleGalleryClick);

        // Control Listeners
        if (lbPrev) lbPrev.addEventListener('click', (e) => { e.stopPropagation(); changeImage('prev'); });
        if (lbNext) lbNext.addEventListener('click', (e) => { e.stopPropagation(); changeImage('next'); });

        lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox) closeLightbox();
        });

        // Keydown handler
        const handleKeydown = (e) => {
            if (!lightbox.classList.contains('open')) return;
            if (e.key === 'Escape') closeLightbox();
            if (e.key === 'ArrowRight') changeImage('next');
            if (e.key === 'ArrowLeft') changeImage('prev');
        };

        document.addEventListener('keydown', handleKeydown);
        
        // Cleanup prevents memory leaks and duplicate listeners
        document.addEventListener('astro:before-swap', () => {
            document.removeEventListener('keydown', handleKeydown);
            document.body.removeEventListener('click', handleGalleryClick);
        }, { once: true });
    });
</script>

<style>
    /* --- LIGHTBOX CONTAINER --- */
    #lightbox {
        position: fixed;
        inset: 0;
        z-index: 50; 
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 350ms ease-in-out, visibility 0s 350ms;
    }
    #lightbox.open {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transition: opacity 350ms ease-in-out, visibility 0s 0s;
    }

    /* Lightbox Image Transition */
    #lightboxImg {
        opacity: 1;
        transition: opacity 350ms ease-in-out, transform 350ms ease-in-out;
    }
    #lightboxImg.opacity-0 { opacity: 0; }

    /* Performance Hint */
    .will-change-opacity {
        will-change: opacity;
    }

    /* --- NAV CONTROLS FADE --- */
    #controls {
        opacity: 0;
        transition: opacity 350ms ease-in-out;
    }
    #lightbox.open #controls { opacity: 1; }

    /* --- CONTROLS STYLING --- */
    .nav-btn, .nav-text {
        font-size: min(1.05svw,2.121svh); 
        font-weight: 500;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: inherit;
    }
    .nav-btn {
        position: relative;
        transition: opacity 350ms ease-in-out;
        cursor: pointer;
        border: none;
        background: transparent;
    }
    .nav-btn:disabled { opacity: 0.3; cursor: default; }
    .nav-text { cursor: default; font-variant-numeric: tabular-nums; }

    .underline-anim {
        padding-bottom: 0.15em; 
        text-decoration: none;
        background-image: linear-gradient(to right, currentColor, currentColor);
        background-repeat: no-repeat;
        background-size: 0% 1px; 
        transition: background-size 0.35s ease-in-out;
    }
    .anim-left { background-position: 0% 100%; }
    .anim-right { background-position: 100% 100%; }
    .group:not(:disabled):hover .underline-anim { background-size: 100% 1px; }

    @media (max-aspect-ratio: 3.1/4) {
        .nav-btn, .nav-text { font-size: min(2.2svw); }
    }
</style>